# Soonyeul Park <ardentpark@gmail.com>, 2018. #zanata
# Sungjin Kang <gang.sungjin@gmail.com>, 2018. #zanata
msgid ""
msgstr ""
"Project-Id-Version: openstack-helm\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-24 23:52+0000\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2018-10-21 06:45+0000\n"
"Last-Translator: Sungjin Kang <gang.sungjin@gmail.com>\n"
"Language-Team: Korean (South Korea)\n"
"Language: ko_KR\n"
"X-Generator: Zanata 4.3.3\n"
"Plural-Forms: nplurals=1; plural=0\n"

msgid ""
"**Note:** The values defined in a PodDisruptionBudget may conflict with "
"other values that have been provided if an operator chooses to leverage "
"Rolling Updates for deployments.  In the case where an operator defines a "
"``maxUnavailable`` and ``maxSurge`` within an update strategy that is higher "
"than a ``minAvailable`` within a pod disruption budget, a scenario may occur "
"where pods fail to be evicted from a deployment."
msgstr ""
"**참고:** PodDisruptionBudget 에 정의된 값들은 운영자가 배포를 위한 롤링 업데"
"이트를 활용하도록 선택한 경우 제공되는 다른 값들과 충돌할 수 있습니다. 운영자"
"가 pod 중단 비용에서의 ``minAvailable`` 보다 큰 ``maxUnavailable`` 과 "
"``maxSurge`` 를 업데이트 전략으로 정의한 경우, 배포에서 pod가 제거되지 않는 "
"시나리오가 발생할 수 있습니다."

msgid ""
":code:`neutron/templates/bin/_neutron-linuxbridge-agent-init.sh.tpl` is "
"configuring the tunnel IP, external bridge and all bridge mappings defined "
"in config. It is done in init container, and the IP for tunneling is shared "
"using file :code:`/tmp/pod-shared/ml2-local-ip.ini` with main linuxbridge "
"container."
msgstr ""
":code:`neutron/templates/bin/_neutron-linuxbridge-agent-init.sh.tpl`은 터널 "
"IP, 외부 브리지, 그리고 config에 정의된 모든 브리지 매핑을 구성합니다.그것은 "
"init 컨테이너에서 완료되고, 터널링을 위한 IP는 :code:`/tmp/pod-shared/ml2-"
"local-ip.ini` 파일을 사용하여 linuxbridge 컨테이너와 공유됩니다."

msgid ""
"A detail worth mentioning is that ovs is configured to use sockets, rather "
"than the default loopback mechanism."
msgstr ""
"언급할 가치가 있는 세부사항은 ovs가 기본 루프백 메커니즘 대신에 소켓을 사용하"
"여 구성된다는 것입니다. "

msgid ""
"A long-term goal, besides being image agnostic, is to also be able to "
"support any of the container runtimes that Kubernetes supports, even those "
"that might not use Docker's own packaging format. This will allow the "
"project to continue to offer maximum flexibility with regard to operator "
"choice."
msgstr ""
"이미지에서 자유로워지는 것 외에도 장기 목표는 Kubernetes가 지원하는 모든 컨테"
"이너 런타임도 지원할 수 있으며, Docker의 자체 패키징 포맷을 사용하지 않는 컨"
"테이너 런타임도 지원할 수 있습니다. 이는 프로젝트에 운영자의 선택과 관련하여 "
"최대한의 유연성을 허용할 것입니다."

msgid ""
"All ``Deployment`` chart components are outfitted by default with rolling "
"update strategies:"
msgstr ""
"모든 ``Deployment`` 차트 구성요소는 기본적으로 롤링 업데이트 전략으로 갖춰집"
"니다:"

msgid "All dependencies described in neutron-dhcp-agent are valid here."
msgstr "neutron-dhcp-agent에 서술된 모든 의존성은 여기에서 유효합니다."

msgid ""
"All of the above configs are endpoints or path to the specific class "
"implementing the interface. You can see the endpoints to class mapping in "
"`setup.cfg <https://github.com/openstack/neutron/"
"blob/412c49b3930ce8aecb0a07aec50a9607058e5bc7/setup.cfg#L69>`_."
msgstr ""
"위의 모든 구성은 인터페이스를 구현하는 특정 클래스에 대한 endpoints나 경로입"
"니다. `setup.cfg <https://github.com/openstack/neutron/"
"blob/412c49b3930ce8aecb0a07aec50a9607058e5bc7/setup.cfg#L69>`_에서 클래스 매"
"핑에 대한 endpoints를 볼 수 있습니다."

msgid ""
"Also note that other non-overridden values are inherited by hosts and labels "
"with overrides. The following shows a set of example hosts and the values "
"fed into the configmap for each:"
msgstr ""
"또한 다른 오버라이드되지 않은 값들은 오버라이드된 호스트와 라벨에 의해 상속됨"
"을 참고하십시오. 다음은 호스트 예시 세트와 각 configmap 에 입력된 값들을 보여"
"줍니다:"

msgid ""
"An illustrative example of an ``images:`` section taken from the heat chart:"
msgstr "heat 차트에서 가져온 ``images:`` 섹션의 실제 사례:"

msgid ""
"Another place where the DHCP agent is dependent on L2 agent is the "
"dependency for the L2 agent daemonset:"
msgstr ""
"DHCP 에이전트가 L2 에이전트에 종속된 위치는 L2 에이전트 deamonset에 대한 종속"
"성입니다:"

msgid ""
"As Helm stands today, several issues exist when you update images within "
"charts that might have been used by jobs that already ran to completion or "
"are still in flight. OpenStack-Helm developers will continue to work with "
"the Helm community or develop charts that will support job removal prior to "
"an upgrade, which will recreate services with updated images. An example of "
"where this behavior would be desirable is when an updated db\\_sync image "
"has updated to point from a Mitaka image to a Newton image. In this case, "
"the operator will likely want a db\\_sync job, which was already run and "
"completed during site installation, to run again with the updated image to "
"bring the schema inline with the Newton release."
msgstr ""
"Helm이 현재 존재하기 때문에, 이미 완료되었거나 진행 중인 작업에서 사용되었을"
"지 모르는 차트에서 이미지 업데이트를 수행할 때 몇 가지 문제가 발생합니다. "
"OpenStack-Helm 개발자는 Helm 커뮤니티와 계속 협력하거나 업그레이드 전에 작업 "
"제거를 지원하는 차트를 개발하여, 업데이트된 이미지로 서비스를 다시 만들 것입"
"니다. 이 동작이 바람직한 예는 업데이트된 db_sync 이미지가 Mitaka 이미지에서 "
"Neuton 이미지를 가리키도록 업데이트 된 경우입니다. 이 경우, 운영자는 사이트 "
"설치 중에 이미 실행되고 완료된 db_sync 작업으로 Newton 릴리즈의 스키마를 가져"
"와 업데이트된 이미지로 다시 실행하기를 원할 수 있습니다."

msgid ""
"As an example, this line uses the ``endpoint_type_lookup_addr`` macro in the "
"``helm-toolkit`` chart (since it is used by all charts). Note that there is "
"a second convention here. All ``{{ define }}`` macros in charts should be "
"pre-fixed with the chart that is defining them. This allows developers to "
"easily identify the source of a Helm macro and also avoid namespace "
"collisions. In the example above, the macro ``endpoint_type_look_addr`` is "
"defined in the ``helm-toolkit`` chart. This macro is passing three "
"parameters (aided by the ``tuple`` method built into the go/sprig templating "
"library used by Helm):"
msgstr ""
"한 예로, 이 명령줄은 ``endpoint_type_lookup_addr`` 매크로를 ``helm-toolkit`` "
"차트에 사용합니다(모든 차트에서 사용되기 때문에). 여기서 두 번째 규칙이 있음"
"을 참고하십시오. 차트의 모든 ``{{ define }}`` 매크로는 그들을 정의하는 차트"
"로 미리 수정되어야 합니다. 이는 개발자들이 Helm 매크로의 소스를 쉽게 식별하"
"고 네임스페이스 충돌을 피할 수 있습니다. 위의 예시에서, "
"``endpoint_type_look_addr`` 매크로는 ``helm-toolkit`` 차트에 정의되어 있습니"
"다. 이 매크로는 3개의 매개 변수를 전달합니다(Helm이 사용하는 go/sprig "
"templating 라이브러리에 내장 된 ``tuple`` 메소드에 의해 지원됩니다):"

msgid ""
"As part of Neutron chart, this daemonset is running Neutron OVS agent. It is "
"dependent on having :code:`openvswitch-db` and :code:`openvswitch-vswitchd` "
"deployed and ready. Since its the default choice of the networking backend, "
"all configuration is in place in `neutron/values.yaml`. :code:`neutron-ovs-"
"agent` should not be deployed when another SDN is used in `network.backend`."
msgstr ""
"Neutron 차트의 일부로서, 이 데몬세트는 Neutron OVS 에이전트를 실행 중입니다. "
"그것은 :code:`openvswitch-db`와 :code:`openvswitch-vswitchd`를 배포하고 준비"
"하는데 의존합니다. 네트워킹 백엔드 기본 선택이기 때문에, 모든 구성은 "
"`neutron/values.yaml`에 위치합니다. 다른 SDN이 `network.backend`에서 사용될 "
"때 :code:`neutron-ovs-agent`를 배포해서는 안됩니다."

msgid ""
"By default, each endpoint is located in the same namespace as the current "
"service's helm chart. To connect to a service which is running in a "
"different Kubernetes namespace, a ``namespace`` can be provided for each "
"individual endpoint."
msgstr ""
"기본적으로, 각 endpoint는 현재 서비스의 helm 차트와 같은 네임스페이스에 위치"
"합니다. 다른 Kubernetes 네임 스페이스에서 실행중인 서비스에 연결하여 각 "
"endpoint에 ``namespace`` 를 제공할 수 있습니다."

msgid ""
"Charts should not use hard coded values such as ``http://keystone-api:5000`` "
"because these are not compatible with operator overrides and do not support "
"spreading components out over various namespaces."
msgstr ""
"차트는 ``http://keystone-api:5000`` 과 같은 하드 코딩된 값을 사용하면 안됩니"
"다. 왜냐하면 이 값들은 운영자의 오버라이드와 호환되지 않으며 다양한 네임스페"
"이스로 확장되는 구성요소들을 지원하지 않기 때문입니다."

msgid ""
"Configuration of OVS bridges can be done via `neutron/templates/bin/_neutron-"
"openvswitch-agent-init.sh.tpl`. The script is configuring the external "
"network bridge and sets up any bridge mappings defined in :code:`network."
"auto_bridge_add`.  These values should align with :code:`conf.plugins."
"openvswitch_agent.ovs.bridge_mappings`."
msgstr ""
"OVS 브리지의 구성은 `neutron/templates/bin/_neutron-openvswitch-agent-init."
"sh.tpl`을 통해 완료될 수 있습니다. 이 스크립트는 외부 네트워크 브리지를 구성"
"하고 :code:`network.auto_bridge_add`에 정의된 브리지 매핑을 설정합니다. 이 값"
"들은 :code:`conf.plugins.openvswitch_agent.ovs.bridge_mappings`에 맞추어야 합"
"니다."

msgid ""
"Configure neutron-server with SDN specific core_plugin/mechanism_drivers."
msgstr ""
"SDN 특정 core_plugin/mechanism_drivers를 사용하여 neutron-server를 구성하십시"
"오."

msgid "Configuring network plugin"
msgstr "네트워크 플러그인 구성"

msgid "Contents:"
msgstr "목차:"

msgid "Create separate chart with new SDN deployment method."
msgstr "새로운 SDN 배포 방법으로 별도의 차트를 생성하십시오."

msgid ""
"Currently OpenStack-Helm supports OpenVSwitch and LinuxBridge as a network "
"virtualization engines. In order to support many possible backends (SDNs), "
"modular architecture of Neutron chart was developed. OpenStack-Helm can "
"support every SDN solution that has Neutron plugin, either core_plugin or "
"mechanism_driver."
msgstr ""
"현재 OpenStack-Helm은 OpenVSwitch 및 LinuxBridge를 네트워크 가상화 엔진으로 "
"지원합니다. 가능한 많은 backend(SDNs)들을 지원하기 위해, Neutron 차트의 모듈"
"식 구조가 개발되었습니다. OpenStack-Helm은 core_plugin 또는 mechanism_driver"
"인 Neutron 플러그인이 있는 모든 SDN 솔루션을 지원할 수 있습니다."

msgid "DHCP - auto-assign IP address and DNS info"
msgstr "DHCP - IP 주소와 DNS 정보 자동 할당"

msgid ""
"DHCP agent is running dnsmasq process which is serving the IP assignment and "
"DNS info. DHCP agent is dependent on the L2 agent wiring the interface. So "
"one should be aware that when changing the L2 agent, it also needs to be "
"changed in the DHCP agent. The configuration of the DHCP agent includes "
"option `interface_driver`, which will instruct how the tap interface created "
"for serving the request should be wired."
msgstr ""
"DHCP 에이전트가 IP 할당 및 DNS 정보를 제공하는 dnsmasq 프로세스를 실행 중입니"
"다. DHCP 에이전트는 인터페이스를 연결하는 L2 에이전트에 의존합니다. 그래서 "
"L2 에이전트를 변경할 때 DHCP 에이전트에서 알고 있어야 하고, 또한 DHCP 에이전"
"트에서 변경될 필요가 있습니다. DHCP 에이전트 구성은 요청을 제공하기 위해 생성"
"된 탭 인터페이스가 어떻게 연결되어야 할지 지시할 interface_driver 옵션을 포함"
"합니다."

msgid "Developer References"
msgstr "개발자 참고자료"

msgid ""
"EFK (Elasticsearch, Fluent-bit & Fluentd, Kibana) based Logging Mechanism"
msgstr "EFK (Elasticsearch, Fluent-bit & Fluentd, Kibana) 기반 로깅 매커니즘"

msgid "Endpoints"
msgstr "Endpoints"

msgid ""
"Fluent-bit, Fluentd meet OpenStack-Helm's logging requirements for "
"gathering, aggregating, and delivering of logged events. Fluent-bit runs as "
"a daemonset on each node and mounts the `/var/lib/docker/containers` "
"directory. The Docker container runtime engine directs events posted to "
"stdout and stderr to this directory on the host. Fluent-bit then forward the "
"contents of that directory to Fluentd. Fluentd runs as deployment at the "
"designated nodes and expose service for Fluent-bit to forward logs. Fluentd "
"should then apply the Logstash format to the logs. Fluentd can also write "
"kubernetes and OpenStack metadata to the logs. Fluentd will then forward the "
"results to Elasticsearch and to optionally Kafka. Elasticsearch indexes the "
"logs in a logstash-* index by default. Kafka stores the logs in a ``logs`` "
"topic by default. Any external tool can then consume the ``logs`` topic."
msgstr ""
"Fluent-bit, Fluentd는 기록된 이벤트의 수집, 집계, 그리고 전달을 위한 로깅 요"
"구사항을 충족합니다. Fluent-bit는 각 노드에서 daemonset으로 실행하고 `/var/"
"lib/docker/containers` 디렉터리를 마운트합니다. Docker 컨테이너 런타임 엔진"
"은 stdout과 stderr에 게시된 이벤트를 호스트의 상기 디렉터리로 보냅니다. 그런 "
"다음 Fluent-bit는 해당 디렉터리의 내용을 Fluentd로 전달합니다. Fluentd는 지정"
"된 노드에서 배포로 동작하고 Fluent-bit의 전달 로그로 서비스를 표시합니다. 그"
"런 다음 Fluentd는 Logstash 포맷을 로그에 적용해야 합니다. Fluentd는 또한 "
"kubernetes와 OpenStack의 메타데이터를 로그에 작성합니다. Fluentd는 그 결과를 "
"Elasticsearch와 선택적으로 Kafka에 전달합니다. Elasticsearch는 기본적으로 로"
"그를 logstash-*로 색인합니다. Kafka는 기본적으로 로그를 ``logs`` 주제로 보관"
"합니다. 그러면 외부 도구가 ``logs`` 주제를 사용할 수 있습니다."

msgid ""
"For instance, in the Neutron chart ``values.yaml`` the following endpoints "
"are defined:"
msgstr ""
"예를 들어, Neutron 차트 ``values.yaml`` 에서 다음과 같은 endpoints가 정의됩니"
"다:"

msgid "Host overrides supercede label overrides"
msgstr "호스트가 대체 라벨의 오버라이드를 오버라이드합니다."

msgid ""
"If :code:`.Values.manifests.daemonset_ovs_agent` will be set to false, "
"neutron ovs agent would not be launched. In that matter, other type of L2 or "
"L3 agent on compute node can be run."
msgstr ""
":code:`.Values.manifests.daemonset_ovs_agent` 가 false로 설정된다면, neutron "
"ovs 에이전트는 시작되지 않을 것입니다. 그 때, 컴퓨트 노드의 다른 타입의 L2나 "
"L3 에이전트가 실행됩니다."

msgid "If required, add new networking agent label type."
msgstr "필요하다면, 새로운 네트워킹 에이전트 라벨 타입을 추가하십시오."

msgid ""
"If the SDN implements its own version of L3 networking, neutron-l3-agent "
"should not be started."
msgstr ""
"SDN이 L3 네트워킹의 한 버전을 구현한다면, neutron-l3-agent는 시작되어서는 안"
"됩니다."

msgid ""
"If the SDN of your choice is using the ML2 core plugin, then the extra "
"options in `neutron/ml2/plugins/ml2_conf.ini` should be configured:"
msgstr ""
"선택한 SDN이 ML2 코어 플러그인을 사용하고 있다면, `neutron/ml2/plugins/"
"ml2_conf.ini` 의 추가 옵션이 구성되어야 합니다:"

msgid "Images"
msgstr "이미지"

msgid ""
"In ``values.yaml`` in each chart, the same defaults are supplied in every "
"chart, which allows the operator to override at upgrade or deployment time."
msgstr ""
"각 차트의 ``values.yaml`` 에는, 업그레이드나 배포 시기에 운영자의 오버라이드"
"가 허용되는 동일한 기본값이 모든 차트에 제공됩니다."

msgid ""
"In order to add support for more SDNs, these steps need to be performed:"
msgstr "더 많은 SDN들을 추가하기 위해서, 이 과정들을 수행할 필요가 있습니다:"

msgid ""
"In order to meet modularity criteria of Neutron chart, section `manifests` "
"in :code:`neutron/values.yaml` contains boolean values describing which "
"Neutron's Kubernetes resources should be deployed:"
msgstr ""
"Neutron 차트의 모듈성 기준을 충족하기 위해서, :code:`neutron/values.yaml`의 "
"섹션 매니페스트는 어떤 Neutron의 Kubernetes 리소스가 배포되어야 하는지 서술하"
"는 boolean 값들을 포함하고 있습니다:"

msgid ""
"In order to use linuxbridge in your OpenStack-Helm deployment, you need to "
"label the compute and controller/network nodes with `linuxbridge=enabled` "
"and use this `neutron/values.yaml` override:"
msgstr ""
"OpenStack-Helm 배치에서 linuxbridge를 사용하기 위해, compute와 controller/"
"network 노드를 `linuxbridge=enabled`로 라벨할 필요가 있고 이것을 `neutron/"
"values.yaml`에 오버라이드하여 사용합니다."

msgid ""
"Introducing a new SDN solution should consider how the above services are "
"provided. It maybe required to disable built-in Neutron functionality."
msgstr ""
"새로운 SDN 솔루션 도입은 위의 서비스가 어떻게 제공되는지를 고려해야합니다. "
"Neutron 내장 함수를 비활성화가 필요할 수도 있습니다."

msgid ""
"L3 agent is serving the routing capabilities for Neutron networks. It is "
"also dependent on the L2 agent wiring the tap interface for the routers."
msgstr ""
"L3 에이전트는 Neutron 네트워크를 위한 라우팅 능력을 제공하고 있습니다. 또한 "
"라우터를 위한 탭 인터페이스를 연결하는 L2 에이전트에 의존합니다."

msgid "L3 routing - creation of routers"
msgstr "L3 라우팅 - 라우터 생성"

msgid "Linuxbridge"
msgstr "Linuxbridge"

msgid ""
"Linuxbridge is the second type of Neutron reference architecture L2 agent. "
"It is running on nodes labeled `linuxbridge=enabled`. As mentioned before, "
"all nodes that are requiring the L2 services need to be labeled with "
"linuxbridge. This includes both the compute and controller/network nodes. It "
"is not possible to label the same node with both openvswitch and linuxbridge "
"(or any other network virtualization technology) at the same time."
msgstr ""
"Linuxbridge는 Neutron 참조 구조 L2 에이전트의 두 번째 타입입니다. 그것은 "
"`linuxbridge=enabled`로 라벨된 노드에서 실행 중입니다. 앞서 언급했듯이, L2 서"
"비스를 요구하는 모든 노드는 linuxbridge로 라벨될 필요가 있습니다. 이는 "
"compute와 controller/network 노드 모두를 포함합니다. 같은 노드에 openvswitch"
"와 linuxbridge (또는 다른 네트워크 가상화 기술)를 동시에 라벨하는 것은 불가능"
"합니다."

msgid "Logging Mechanism"
msgstr "로깅 매커니즘"

msgid "Logging Requirements"
msgstr "로깅 요구사항"

msgid "Metadata - Provide proxy for Nova metadata service"
msgstr "메타데이터 - Nova 메타데이터 서비스를 위한 프록시 제공"

msgid ""
"Metadata-agent is a proxy to nova-metadata service. This one provides "
"information about public IP, hostname, ssh keys, and any tenant specific "
"information. The same dependencies apply for metadata as it is for DHCP and "
"L3 agents. Other SDNs may require to force the config driver in nova, since "
"the metadata service is not exposed by it."
msgstr ""
"Metadata-agent는 nova-metadata 서비스에 대한 프록시입니다. 이것은 공용 IP, 호"
"스트명, ssh 키, 그리고 tenant 특정 정보에 대한 정보를 제공합니다. DHCP와 L3 "
"에이전트와 마찬가지로 메타데이터에도 동일한 의존성을 적용합니다. 다른 SDN은 "
"메타데이터 서비스가 노출되어 있지 않으므로 nova에서 드라이버 구성을 강제할 것"
"을 요구할지도 모릅니다."

msgid "Networking"
msgstr "네트워킹"

msgid "Neutron architecture"
msgstr "Neutron 구조"

msgid "Neutron chart includes the following services:"
msgstr "Neutron 차트는 다음의 서비스들을 포함합니다:"

msgid ""
"Neutron-server service is scheduled on nodes with `openstack-control-"
"plane=enabled` label."
msgstr ""
"Neutron-server 서비스는 `openstack-control-plane=enabled` 라벨로 노드에 스케"
"줄됩니다."

msgid "Node and label specific configurations"
msgstr "노드와 라벨 특정 구성"

msgid "Note that only one set of overrides is applied per node, such that:"
msgstr ""
"노드마다 다음과 같이 단 하나의 오버라이드 세트만 적용되는 점을 참고하십시오:"

msgid ""
"Note that some additional values have been injected into the config file, "
"this is performed via statements in the configmap template, which also calls "
"the ``helm-toolkit.utils.to_oslo_conf`` to convert the yaml to the required "
"layout:"
msgstr ""
"구성 파일에 몇 가지 추가 값들이 주입되었음을 참고하십시오, 이는 configmap 템"
"플릿의 문장을 통해 수행되며, 또한 yaml을 필요한 레이아웃으로 변환하기 위해 "
"``helm-toolkit.utils.to_oslo_conf`` 를 호출합니다:"

msgid ""
"Note: Rolling update values can conflict with values defined in each "
"service's PodDisruptionBudget.  See `here <https://docs.openstack.org/"
"openstack-helm/latest/devref/pod-disruption-budgets.html>`_ for more "
"information."
msgstr ""
"참고: 롤링 업데이트 값은 각 서비스의 PodDisruptionBudget에 정의된 값들과 충돌"
"할 수 있습니다. 자세한 정보는 `여기 <https://docs.openstack.org/openstack-"
"helm/latest/devref/pod-disruption-budgets.html>`_ 를 참조하십시오."

msgid "Nova config dependency"
msgstr "Nova config 의존성"

msgid "OSLO-Config Values"
msgstr "OSLO-Config 값"

msgid ""
"OpenStack-Helm defines a centralized logging mechanism to provide insight "
"into the state of the OpenStack services and infrastructure components as "
"well as underlying Kubernetes platform. Among the requirements for a logging "
"platform, where log data can come from and where log data need to be "
"delivered are very variable. To support various logging scenarios, OpenStack-"
"Helm should provide a flexible mechanism to meet with certain operation "
"needs."
msgstr ""
"OpenStack-Helm은 OpenStack 서비스와 인프라 구성요소의 상태 뿐만 아니라 기본 "
"Kubernetes 플랫폼에 대한 통찰력을 제공하는 중앙 집중식 로깅 메커니즘을 정의합"
"니다. 로깅 플랫폼에 대한 요구사항 중 로그 데이터를 가져올 곳과 로그 데이터를 "
"전달되어야 할 곳은 매우 다양합니다. 다양한 로깅 시나리오를 지원하기 위해서, "
"OpenStack-Helm은 특정 작업 요구를 충족할 수 있는 유연한 메커니즘을 제공해야 "
"합니다."

msgid ""
"OpenStack-Helm generates oslo-config compatible formatted configuration "
"files for services dynamically from values specified in a yaml tree. This "
"allows operators to control any and all aspects of an OpenStack services "
"configuration. An example snippet for an imaginary Keystone configuration is "
"described here:"
msgstr ""
"OpenStack-Helm은 yaml 트리에 지정된 값에서 동적으로 서비스를 위한 oslo-"
"config 호환 형식의 구성 파일을 생성합니다. 이는 운영자가 OpenStack 서비스 구"
"성 전반을 제어할 수 있도록 합니다. 가상의 키스톤 구성에 대한 짧은 예시가 여"
"기 있습니다:"

msgid ""
"OpenStack-Helm leverages PodDistruptionBudgets to enforce quotas that ensure "
"that a certain number of replicas of a pod are available at any given time.  "
"This is particularly important in the case when a Kubernetes node needs to "
"be drained."
msgstr ""
"OpenStack-Helm은 주어진 시간에 특정 수의 pod 복제본의 가용성을 보장하도록 할"
"당량을 강제하기 위해 PodDistruptionBudget을 활용합니다. 이는 Kubernetes 노드"
"가 빠져야 될 필요가 있는 경우에 특히 중요합니다."

msgid ""
"OpenStack-Helm provides fast and lightweight log forwarder and full featured "
"log aggregator complementing each other providing a flexible and reliable "
"solution. Especially, Fluent-bit is used as a log forwarder and Fluentd is "
"used as a main log aggregator and processor."
msgstr ""
"OpenStack-Helm은 신속하고 가벼운 로그 전달자와 완전한 기능을 갖춘 로그 수집기"
"를 제공하여 서로 보완하여 유연하고 신뢰할 수 있는 솔루션을 제공합니다. 특히, "
"Fluent-bit는 로그 전달자로 사용되고 Fluentd는 주 로그 수집기와 프로세서로 사"
"용됩니다."

msgid "OpenVSwitch"
msgstr "OpenVSwitch"

msgid "Other SDNs"
msgstr "다른 SDN들"

msgid "Other networking services provided by Neutron are:"
msgstr "Neutron에 의해 제공되는 다른 네트워킹 서비스:"

msgid "Pod Disruption Budgets"
msgstr "Pod 중단 비용"

msgid ""
"SDNs implementing ML2 driver can add extra/plugin-specific configuration "
"options in `neutron/ml2/plugins/ml2_conf.ini`. Or define its own "
"`ml2_conf_<name>.ini` file where configs specific to the SDN would be placed."
msgstr ""
"ML2 드라이버를 구현하는 SDN은 extra/plugin-specific 구성 옵션을 `neutron/ml2/"
"plugins/ml2_conf.ini`에 추가할 수 있습니다. 또는 SDN의 고유 구성이 배치될 자"
"체 `ml2_conf_<name>.ini` 파일을 정의하십시오."

msgid ""
"Script in :code:`neutron/templates/bin/_neutron-openvswitch-agent-init.sh."
"tpl` is responsible for determining the tunnel interface and its IP for "
"later usage by :code:`neutron-ovs-agent`. The IP is set in init container "
"and shared between init container and main container with :code:`neutron-ovs-"
"agent` via file :code:`/tmp/pod-shared/ml2-local-ip.ini`."
msgstr ""
":code:`neutron/templates/bin/_neutron-openvswitch-agent-init.sh.tpl`의 스크립"
"트는 :code:`neutron-ovs-agent`에 의한 나중의 사용을 위한 터널 인터페이스와 IP"
"를 결정할 책임이 있습니다. IP는 init 컨테이너에 설정되고 init 컨테이너와 "
"main 컨테이너 사이에서 :code:`/tmp/pod-shared/ml2-local-ip.ini`을 통한 :code:"
"`neutron-ovs-agent`로 공유됩니다."

msgid ""
"Specify if new SDN would like to use existing services from Neutron: L3, "
"DHCP, metadata."
msgstr ""
"새로운 SDN이 Neutron의 기존 서비스들을 사용할지 명시하십시오: L3, DHCP, 메타"
"데이터."

msgid ""
"The Neutron reference architecture provides mechanism_drivers :code:"
"`OpenVSwitch` (OVS) and :code:`linuxbridge` (LB) with ML2 :code:"
"`core_plugin` framework."
msgstr ""
"Neutron 참조 구조는 ML2 :code:`core_plugin` 프레임워크와 함께 :code:"
"`OpenVSwitch` (OVS) 와 :code:`linuxbridge` (LB) mechanism_drivers를 제공합니"
"다."

msgid ""
"The OpenStack-Helm project also implements annotations across all chart "
"configmaps so that changing resources inside containers, such as "
"configuration files, triggers a Kubernetes rolling update. This means that "
"those resources can be updated without deleting and redeploying the service "
"and can be treated like any other upgrade, such as a container image change."
msgstr ""
"OpenStack-Helm 프로젝트는 또한 모든 차트 configmap에 annotations를 구현하여 "
"구성 파일과 같은 컨테이너 내부의 변경 리소스가 Kubernetes 롤링 업데이트를 촉"
"발합니다. 이는 서비스를 삭제하거나 재배포하지 않고 해당 리소스들에 대한 업데"
"이트를 할 수 있으며 컨테이너 이미비 변경과 같은 다른 업그레이드와 같이 처리 "
"할 수 있음을 의미합니다."

msgid ""
"The OpenStack-Helm project assumes all upgrades will be done through Helm. "
"This includes handling several different resource types. First, changes to "
"the Helm chart templates themselves are handled. Second, all of the "
"resources layered on top of the container image, such as ``ConfigMaps`` "
"which includes both scripts and configuration files, are updated during an "
"upgrade. Finally, any image references will result in rolling updates of "
"containers, replacing them with the updating image."
msgstr ""
"OpenStack-Helm 프로젝트는 모든 업그레이드가 Helm을 통해 수행된다고 가정합니"
"다. 이는 몇몇 다른 리소스 타입의 처리를 포함합니다. 첫째, Helm 차트 템플릿 자"
"체의 변경이 처리됩니다. 둘째, ``ConfigMaps`` 와 같이 컨테이너 이미지 위에 계"
"층화된 모든 리소스가 업그레이드 중에 업데이트 됩니다. 마지막으로, 모든 이미"
"지 참조는 컨테이너의 롤링 업데이트를 가져오고, 업데이트한 이미지로 대체합니"
"다."

msgid ""
"The OpenStack-Helm project today uses a mix of Docker images from "
"Stackanetes and Kolla, but will likely standardize on a default set of "
"images for all charts without any reliance on image-specific utilities."
msgstr ""
"OpenStack-Helm 프로젝트는 현재 Stackanetes와 Kolla의 Docker 이미지를 혼합하"
"여 사용하지만, 이미지 특정 유틸리티에 의존하지 않고 모든 차트를 위한 기본 이"
"미지 세트를 표준화할 것입니다."

msgid ""
"The ``hash`` function defined in the ``helm-toolkit`` chart ensures that any "
"change to any file referenced by configmap-bin.yaml or configmap-etc.yaml "
"results in a new hash, which will then trigger a rolling update."
msgstr ""
"``helm-toolkit`` 차트에서 정의된 ``hash`` 함수는 configmap-bin.yaml 또는 "
"configmap-etc.yaml에서 참조되는 모든 파일에 대한 변화가 롤링 업데이트를 촉발"
"할 새로운 hash를 생성하는 것을 보장합니다."

msgid "The above configuration options are handled by `neutron/values.yaml`:"
msgstr "위의 구성 옵션은 'neutrol/values.yaml` 에 의해 조절됩니다:"

msgid ""
"The farther down the list the label appears, the greater precedence it has. "
"e.g., \"another-label\" overrides will apply to a node containing both "
"labels."
msgstr ""
"라벨이 표시된 목록이 낮을수록, 우선순위가 높아집니다. 예를 들어, \\\"another-"
"label\\\" 의 오버라이드는 두 라벨 모두를 포함한 노드에 적용될 것입니다. "

msgid ""
"The following standards are in use today, in addition to any components "
"defined by the service itself:"
msgstr ""
"서비스 자체로 정의된 구성요소 외에도, 다음의 표준들이 현재 사용되고 있습니다."

msgid ""
"The macros that help translate these into the actual URLs necessary are "
"defined in the ``helm-toolkit`` chart. For instance, the cinder chart "
"defines a ``glance_api_servers`` definition in the ``cinder.conf`` template:"
msgstr ""
"이들을 실제 필요한 URL로 변환하는 데 도움이 되는 매크로는 ``helm-toolkit`` 차"
"트에 정의되어 있습니다. 예를 들어, cinder 차트는 ``glance_api_servers`` 정의"
"를 ``cinder.conf`` 템플릿에 정의합니다:"

msgid ""
"The ovs set of daemonsets are running on the node labeled "
"`openvswitch=enabled`. This includes the compute and controller/network "
"nodes. For more flexibility, OpenVSwitch as a tool was split out of Neutron "
"chart, and put in separate chart dedicated OpenVSwitch. Neutron OVS agent "
"remains in Neutron chart. Splitting out the OpenVSwitch creates "
"possibilities to use it with different SDNs, adjusting the configuration "
"accordingly."
msgstr ""
"데몬세트의 ovs 세트는 `openvswitch=enabled`로 라벨된 노드에서 실행 중입니다. "
"이는 compute와 controller/network 노드를 포함합니다. 유연성을 높이기 위해서, "
"OpenVSwitch를 도구로 사용하여 Neutron 차트를 분리하고 OpenVSwitch 전용의 별"
"도 차트를 넣었습니다. Neutron OVS 에이전트는 Neutron 차트에 남아있습니다. "
"OpenVSwitch를 분할하면 다른 SDN과 함께 사용할 수 있는 가능성이 생기기 때문"
"에, 적절하게 구성을 조정합니다."

msgid ""
"The project's core philosophy regarding images is that the toolsets required "
"to enable the OpenStack services should be applied by Kubernetes itself. "
"This requires OpenStack-Helm to develop common and simple scripts with "
"minimal dependencies that can be overlaid on any image that meets the "
"OpenStack core library requirements. The advantage of this is that the "
"project can be image agnostic, allowing operators to use Stackanetes, Kolla, "
"LOCI, or any image flavor and format they choose and they will all function "
"the same."
msgstr ""
"이미지에 관한 프로젝트의 핵심 철학은 OpenStack 서비스를 활성화하는 데 필요한 "
"도구모음이 Kubernetes 자체에서 적용되어야 한다는 것입니다. 이는 OpenStack-"
"Helm에 OpenStack 핵심 라이브러리의 요구사항을 충족하는 이미지들에 중첩될 수 "
"있는 최소한의 의존성으로 일반적이고 단순한 스크립트를 개발할 것을 요구합니"
"다. 이것의 장점은 운영자들이 Stackanetes, Kolla, LOCI, 또는 그들이 선택하고 "
"동일하게 기능할 이미지 flavor와 포맷을 사용하는 것을 허락하여 프로젝트가 이미"
"지에서 자유로워지는 것입니다."

msgid ""
"The project's goal is to provide a consistent mechanism for endpoints. "
"OpenStack is a highly interconnected application, with various components "
"requiring connectivity details to numerous services, including other "
"OpenStack components and infrastructure elements such as databases, queues, "
"and memcached infrastructure. The project's goal is to ensure that it can "
"provide a consistent mechanism for defining these \"endpoints\" across all "
"charts and provide the macros necessary to convert those definitions into "
"usable endpoints. The charts should consistently default to building "
"endpoints that assume the operator is leveraging all charts to build their "
"OpenStack cloud. Endpoints should be configurable if an operator would like "
"a chart to work with their existing infrastructure or run elements in "
"different namespaces."
msgstr ""
"프로젝트의 목표는 endpoints에 대한 일관된 매커니즘을 제공하는 것입니다. "
"OpenStack은 다른 OpenStack 구성요소 와 데이터베이스, 큐, 그리고 memcached 인"
"프라와 같은 인프라 요소를 포함하여 다양한 서비스에 대한 연결 세부 사항을 필요"
"로 하는 다양한 구성요소와 고도로 상호 연결된 응용 프로그램입니다. 프로젝트의 "
"목표는 모든 차트에서 이러한 \"endpoints\"를 정의하는 일관된 메커니즘을 제공하"
"고 이러한 정의를 유용한 endpoints로 변환하는 데 필요한 매크로를 제공하는 것입"
"니다. 차트는 운영자가 그들의 OpenStack 클라우드를 구축하기 위하여 모든 차트"
"를 활용하고 있다고 가정하고 endpoints 구축을 일관되게 기본값으로 설정해야 합"
"니다. 운영자가 차트를 그들의 기존 인프라와 함께 사용하기를 원하거나 다른 네임"
"스페이스의 요소를 실행하려면 Endpoints를 구성 할 수 있어야 합니다."

msgid ""
"The resulting logs can then be queried directly through Elasticsearch, or "
"they can be viewed via Kibana. Kibana offers a dashboard that can create "
"custom views on logged events, and Kibana integrates well with Elasticsearch "
"by default."
msgstr ""
"로그의 결과는 Elasticsearch를 통해 직접 쿼리하거나 Kibana를 통해 볼 수 있습니"
"다. Kibana는 기록된 이벤트에 대한 사용자 정의 뷰를 만들 수 있는 대시보드를 제"
"공하며 Kibana는 기본적으로 Elasticsearch와 잘 통합됩니다."

msgid ""
"There are situations where we need to define configuration differently for "
"different nodes in the environment. For example, we may require that some "
"nodes have a different vcpu_pin_set or other hardware specific deltas in "
"nova.conf."
msgstr ""
"환경의 각각의 노드들에 대해 구성을 다르게 정의해야 하는 상황이 있습니다. 예"
"를 들어, 어떤 노드가 nova.conf 에서 다른 vcpu_pi_set 또는 다른 하드웨어 특정 "
"delta를 갖도록 요구할 수 있습니다."

msgid ""
"There is also a need for DHCP agent to pass ovs agent config file (in :code:"
"`neutron/templates/bin/_neutron-dhcp-agent.sh.tpl`):"
msgstr ""
"또한 DHCP 에이전트가 ovs 에이전트 구성 파일을 전달할 필요가 있습니다(:code:"
"`neutron/templates/bin/_neutron-dhcp-agent.sh.tpl` 내):"

msgid ""
"These quotas are configurable by modifying the ``minAvailable`` field within "
"each PodDistruptionBudget manifest, which is conveniently mapped to a "
"templated variable inside the ``values.yaml`` file. The ``min_available`` "
"within each service's ``values.yaml`` file can be represented by either a "
"whole number, such as ``1``, or a percentage, such as ``80%``.  For example, "
"when deploying 5 replicas of a pod (such as keystone-api), using "
"``min_available: 3`` would enforce policy to ensure at least 3 replicas were "
"running, whereas using ``min_available: 80%`` would ensure that 4 replicas "
"of that pod are running."
msgstr ""
"이러한 할당량은 ``values.yaml`` 파일 내부의 템플릿 변수에 편리하게 매핑된 각 "
"PodDistruptionBudget 매니페스트 내의 ``minAvailable`` 필드를 수정하여 구성할 "
"수 있습니다. 각 서비스의 ``values.yaml`` 파일 내 ``min_available`` 는 ``1`` "
"과 같은 정수나 ``80%`` 와 같은 퍼센트로 표현될 수 있습니다. 예를 들어, 5개의 "
"pod 복제본(keystone-api)을 배포할 때, ``mun_available: 3``을 사용하면 적어도 "
"3개의 복제본의 실행을 보장하도록 정책을 강제하는 반면, ``min_available: "
"80%`` 을 사용하면 4개의 복제본의 실행을 보장할 수 있습니다."

msgid ""
"These values define all the endpoints that the Neutron chart may need in "
"order to build full URL compatible endpoints to various services. Long-term, "
"these will also include database, memcached, and rabbitmq elements in one "
"place. Essentially, all external connectivity can be defined centrally."
msgstr ""
"이 값들은 Neutron 차트가 다양한 서비스에 URL과 완전 호환되는 endpoints를 구축"
"하는데 필요할 수 있는 모든 endpoints를 정의합니다. 장기적으로, 이들은 또한 데"
"이터베이스, memcached, 그리고 rabbitmq 요소들을 한 곳에 포함할 것입니다. 근본"
"적으로, 모든 외부 연결을 중앙에서 정의할 수 있습니다."

msgid ""
"This daemonset includes the linuxbridge Neutron agent with bridge-utils and "
"ebtables utilities installed. This is all that is needed, since linuxbridge "
"uses native kernel libraries."
msgstr ""
"이 daemonset은 bridge-utils와 ebtables 유틸리티가 설치된 linuxbridge Neutron "
"에이전트를 포함합니다.linuxbridge가 네이티브 커널 라이브러리를 사용하기 때문"
"에 이 모든 것이 필요합니다."

msgid "This is accomplished with the following annotation:"
msgstr "이는 다음 annotation으로 수행됩니다:"

msgid ""
"This option will allow to configure the Neutron services in proper way, by "
"checking what is the actual backed set in :code:`neutron/values.yaml`."
msgstr ""
"이 옵션은 :code:`neutron/values.yaml`의 실제 backend set이 무엇인지 확인하"
"여, Neuron 서비스를 적절한 방법으로 구성할 수 있도록 허락할 것입니다."

msgid ""
"This requirement is OVS specific, the `ovsdb_connection` string is defined "
"in `openvswitch_agent.ini` file, specifying how DHCP agent can connect to "
"ovs. When using other SDNs, running the DHCP agent may not be required. When "
"the SDN solution is addressing the IP assignments in another way, neutron's "
"DHCP agent should be disabled."
msgstr ""
"이 요구사항은 OVS 특정이며, `ovsdb_connection` 문자열은 DHCP 에이전트가 어떻"
"게 ovs에 연결할 수 있는지 명세하는 `openvswitch_agent.ini` 파일에 정의됩니"
"다. 다른 SDN을 사용할 때, DHCP 에이전트 실행은 요구되지 않을 것입니다. SDN 솔"
"루션이 다른 방식으로 IP 할당을 지정할 때, neutron의 DHCP 에이전트를 비활성화"
"해야 합니다."

msgid ""
"This runs the OVS tool and database. OpenVSwitch chart is not Neutron "
"specific, it may be used with other technologies that are leveraging the OVS "
"technology, such as OVN or ODL."
msgstr ""
"이것은 OVS 툴과 데이터베이스를 실행합니다. OpenVSwitch 차트는 특정 Neutron이 "
"아니라, OVN이나 ODL과 같은 OVS 기술을 활용하는 다른 기술들에 사용될 것입니다."

msgid ""
"This will be consumed by the templated ``configmap-etc.yaml`` manifest to "
"produce the following config file:"
msgstr ""
"이것은 템플릿화 된 ``configmap-etc.yaml`` 매니페스트에 의해 다음의 구성 파일"
"을 생산하기 위해 소비될 것입니다:"

msgid ""
"To be able to configure multiple networking plugins inside of OpenStack-"
"Helm, a new configuration option is added:"
msgstr ""
"OpenStack-Helm 내 다중 네트워킹 플러그인을 구성하는 것을 가능하게 하기 위해"
"서, 새로운 구성 옵션이 추가되었습니다:"

msgid ""
"To do this, we can specify overrides in the values fed to the chart. Ex:"
msgstr "이를 위해, 차트에 입력된 값의 오버라이드를 명시할 수 있습니다. 예시:"

msgid ""
"To enable new SDN solution, there should be separate chart created, which "
"would handle the deployment of service, setting up the database and any "
"related networking functionality that SDN is providing."
msgstr ""
"새로운 SDN 솔루션을 가능하게 하기 위해 서비스 배포, 데이터베이스 설정, 그리"
"고 SDN이 제공하고 있는 관련된 모든 네트워크 기능을 처리하는 별도의 차트가 생"
"성되어 있어야 합니다."

msgid ""
"To that end, all charts provide an ``images:`` section that allows operators "
"to override images. Also, all default image references should be fully "
"spelled out, even those hosted by Docker or Quay. Further, no default image "
"reference should use ``:latest`` but rather should be pinned to a specific "
"version to ensure consistent behavior for deployments over time."
msgstr ""
"이를 위해, 모든 차트는 운영자들이 이미지를 오버라이드할 수 있는 ``images`` 섹"
"션을 제공합니다. 또한, 모든 기본 이미지 참조는 Docker 또는 Quay에 의해 호스팅"
"되었더라도 완전히 작성되어야 합니다. 나아가, 어떤 기본 이미지 참조도 ``:"
"latest` 를 사용하면 안되지만, 대신에 배포 후에 일관된 동작을 보장하는 특정 버"
"전으로 고정되어야 합니다."

msgid ""
"To use other Neutron reference architecture types of SDN, these options "
"should be configured in :code:`neutron.conf`:"
msgstr ""
"다른 Neutron 참조 구조 타입의 SDN을 사용하려면, 이러한 옵션을 neutron.conf에"
"서 구성해야 합니다:"

msgid ""
"Today, the ``images:`` section has several common conventions. Most "
"OpenStack services require a database initialization function, a database "
"synchronization function, and a series of steps for Keystone registration "
"and integration. Each component may also have a specific image that composes "
"an OpenStack service. The images may or may not differ, but regardless, "
"should all be defined in ``images``."
msgstr ""
"현재, ``images:`` 섹션에는 몇가지 규칙이 있습니다. 대부분의 OpenStack 서비스"
"는 데이터베이스 초기화 기능, 데이터베이스 동기화 기능, 그리고 Keystone 등록"
"과 통합을 위한 단계를 요구합니다. 각 구성요소에는 OpenStack 서비스를 구성하"
"는 특정 이미지가 있을 수도 있습니다. 이미지는 다를 수 있지만, 이에 관계없이 "
"모두 ``images``에 정의되어야 합니다."

msgid "Typical networking API request is an operation of create/update/delete:"
msgstr "일반적인 네트워킹 API 요청은 생성/갱신/삭제 작업입니다:"

msgid "Upgrades and Reconfiguration"
msgstr "업그레이드 및 재구성"

msgid ""
"Whenever we change the L2 agent, it should be reflected in `nova/values."
"yaml` in dependency resolution for nova-compute."
msgstr ""
"L2 에이전트를 변경할 때마다, nova-compute를 위한 의존성 결정을 `nova/values."
"yaml` 에 반영해야 합니다."

msgid ""
"``host1.fqdn`` with labels ``compute-type: dpdk, sriov`` and ``another-"
"label: another-value``:"
msgstr ""
"``compute-type: dpdk, sriov`` 와 ``another-label: another-value`` 라벨의 "
"``host1.fqdn`` :"

msgid ""
"``host2.fqdn`` with labels ``compute-type: dpdk, sriov`` and ``another-"
"label: another-value``:"
msgstr ""
"``compute-type: dpdk, sriov`` 와 ``another-label: another-value`` 라벨의 "
"``host2.fqdn`` :"

msgid ""
"``host3.fqdn`` with labels ``compute-type: dpdk, sriov`` and ``another-"
"label: another-value``:"
msgstr ""
"``compute-type: dpdk, sriov`` 와 ``another-label: another-value`` 라벨의 "
"``host3.fqdn`` :"

msgid "``host4.fqdn`` with labels ``compute-type: dpdk, sriov``:"
msgstr "``compute-type: dpdk, sriov`` 라벨의 ``host4.fqdn`` :"

msgid "``host5.fqdn`` with no labels:"
msgstr "라벨이 없는 ``host5.fqdn`` :"

msgid ""
"api: This is the port to map to for the service. Some components, such as "
"glance, provide an ``api`` port and a ``registry`` port, for example."
msgstr ""
"api : 이것은 서비스에 매핑할 포트입니다. 예를 들어 glance와 같은 어떤 구성요"
"소들은 ``api`` 포트와 ``registry`` 포트를 제공합니다."

msgid ""
"db\\_drop: The image that will perform database deletion operations for the "
"OpenStack service."
msgstr "db\\_drop: OpenStack 서비스를 위한 데이터베이스 삭제를 수행할 이미지"

msgid ""
"db\\_init: The image that will perform database creation operations for the "
"OpenStack service."
msgstr ""
"db\\_init: OpenStack 서비스를 위한 데이터베이스 생성 작업을 수행할 이미지"

msgid ""
"db\\_sync: The image that will perform database sync (schema initialization "
"and migration) for the OpenStack service."
msgstr ""
"db\\_sync: OpenStack 서비스를 위한 데이터베이스 동기화(초기화와 이동 스키마)"
"를 수행할 이미지"

msgid ""
"dep\\_check: The image that will perform dependency checking in an init-"
"container."
msgstr "dep\\_check: init-container에서 의존성 검사를 수행할 이미지."

msgid ""
"image: This is the OpenStack service that the endpoint is being built for. "
"This will be mapped to ``glance`` which is the image service for OpenStack."
msgstr ""
"image : 이것은 endpoint가 구축하고 있는 OpenStack 서비스입니다. 이것은 "
"OpenStack을 위한 이미지 서비스인 ``glance``로 매핑될 것입니다."

msgid ""
"internal: This is the OpenStack endpoint type we are looking for - valid "
"values would be ``internal``, ``admin``, and ``public``"
msgstr ""
"internal : 이것은 우리가 찾고 있는 OpenStack endpoint 타입입니다. - 유효한 값"
"은 ``internal``, ``admin``, 그리고 ``public`` 입니다."

msgid ""
"ks\\_endpoints: The image that will perform keystone endpoint registration "
"for the service."
msgstr "ks\\_endpoints: 서비스를 위한 키스톤 endpoint 등록을 수행할 이미지"

msgid ""
"ks\\_service: The image that will perform keystone service registration for "
"the service."
msgstr "ks\\_service: 서비스를 위한 키스톤 사용자 등록을 수행할 이미지"

msgid ""
"ks\\_user: The image that will perform keystone user creation for the "
"service."
msgstr "ks\\_user : 서비스를 위한 키스톤 사용자 생성을 수행할 이미지"

msgid "network"
msgstr "네트워크"

msgid "neutron-dhcp-agent"
msgstr "neutron-dhcp-agent"

msgid ""
"neutron-dhcp-agent service is scheduled to run on nodes with the label "
"`openstack-control-plane=enabled`."
msgstr ""
"neutron-dhcp-agent 서비스는 `openstack-control-plane=enabled` 라벨로 노드에"
"서 실행되도록 스케줄됩니다."

msgid "neutron-l3-agent"
msgstr "neutron-l3-agent"

msgid ""
"neutron-l3-agent service is scheduled to run on nodes with the label "
"`openstack-control-plane=enabled`."
msgstr ""
"neutron-l3-agent 서비스는 `openstack-control-plane=enabled` 라벨로 노드에서 "
"실행되도록 스케줄됩니다."

msgid "neutron-lb-agent"
msgstr "neutron-lb-agent"

msgid "neutron-metadata-agent"
msgstr "neutron-metadata-agent"

msgid ""
"neutron-metadata-agent service is scheduled to run on nodes with the label "
"`openstack-control-plane=enabled`."
msgstr ""
"neutron-metadata-agent 서비스는 `openstack-control-plane=enabled` 라벨로 노드"
"에서 실행되도록 스케줄됩니다."

msgid "neutron-ovs-agent"
msgstr "neutron-ovs-agent"

msgid "neutron-server"
msgstr "neutron-server"

msgid ""
"neutron-server is serving the networking REST API for operator and other "
"OpenStack services usage. The internals of Neutron are highly flexible, "
"providing plugin mechanisms for all networking services exposed. The "
"consistent API is exposed to the user, but the internal implementation is up "
"to the chosen SDN."
msgstr ""
"neutron-server는 운영자와 다른 OpenStack 서비스 사용을 위한 네트워킹 REST API"
"를 제공합니다. Neutron 내부 구조는 유연성이 뛰어나, 노출된 모든 네트워킹 서비"
"스를 위한 플러그인 매커니즘을 제공합니다. 일관된 API는 사용자에게 노출되지"
"만, 내부 구현은 선택된 SDN가 결정합니다."

msgid "openvswitch-db and openvswitch-vswitchd"
msgstr "openvswitch-db와 openvswitch-vswitchd"

msgid "port"
msgstr "포트"

msgid ""
"pull\\_policy: The image pull policy, one of \"Always\", \"IfNotPresent\", "
"and \"Never\" which will be used by all containers in the chart."
msgstr ""
"pull\\_policy: 차트 내 모든 컨테이너가 사용할 \"Always\", \"IfNotPresent\", "
"그리고 \"Never\" 중 하나의 이미지 pull 정책"

msgid "subnet"
msgstr "서브넷"
